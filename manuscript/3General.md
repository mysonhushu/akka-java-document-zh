# 3 Akka 概论

## 3.1 术语，概念

在本章中，我们尝试建立一个通用术语，以便为Akka所针对的并发分布式系统进行通信奠定坚实的基础。 请注意，对于其中许多条款，没有单一的商定定义。 我们只是寻求提供将在Akka文档范围内使用的工作定义。　

### 3.1.1 并发(Concurrency) VS. 平行(Parallelism)

并发和并行是相关的概念，但存在细微差别。 并发意味着两个或多个任务正在取得进展，即使它们可能没有同时执行。 例如，这可以通过时间切片来实现，其中任务的各部分被顺序执行并与其他任务的一部分混合。 另一方面，当执行可以真正同时发生时，并行性就出现了。

### 3.1.2 异步(Asynchronous) VS. 同步(Synchronous)

如果调用方在方法返回值或抛出异常之前无法进行，则方法调用被视为同步。 另一方面，异步调用允许调用者在有限数量的步骤之后前进，并且可以通过一些附加机制, 它可以是注册的回调 (registered callback)，Future 或消息(message) 来发信号通知方法的完成。

同步 API 可以使用阻塞来实现同步，但这不是必需的。 CPU 密集型任务可能会产生与阻塞类似的行为。 通常，最好使用异步 API，因为它们可以保证系统能够进步。 Actors 本质上是异步的：一个 actor 可以在发送消息后继续进行而不等待实际的传递发生。

### 3.1.3 非阻塞(Non-blocking) VS. 阻塞(Blocking)

如果一个线程的延迟可以无限延迟一些其他线程，我们称之为阻塞。 一个很好的例子是一个资源，它可以由一个使用互斥的线程专门使用。 如果线程无限期地保留资源（例如，意外地运行无限循环），则等待资源的其他线程无法进行。 相反，非阻塞意味着没有线程能够无限期地延迟其他线程。

非阻塞操作比阻塞操作更受欢迎，因为当它包含阻塞操作时，系统的整体进度并不是很容易保证。

### 3.1.4 死锁(DeadLock) VS. 饥饿(Starvation) VS. 活锁(Live-Lock)

当几个参与者彼此等待达到特定状态以便能够进展时，就会出现死锁。 由于在没有其他参与者达到某种状态（“Catch-22”问题）的情况下，他们都无法进步，所有受影响的子系统都会失速。 死锁与阻塞密切相关，因为参与者线程必须能够无限期地延迟其他线程的进展。

在死锁的情况下，没有参与者可以取得进展，而相反，当有参与者可以取得进展时，会发生饥饿，但可能有一个或多个不可能。 典型情况是天真调度算法的情况，该算法总是在低优先级任务上选择高优先级任务。 如果传入的高优先级任务的数量足够高，则不会完成任何低优先级任务。

Livelock类似于死锁，因为没有参与者取得进展。 但不同的是，参与者不是在等待其他人进步的状态下被冻结，而是不断改变他们的状态。 两个参与者有两个相同资源可用的示例场景。 他们每个人都试图获取资源，但他们也会检查其他人是否也需要资源。 如果资源是由其他参与者请求的，则他们尝试获取该资源的另一个实例。 在不幸的情况下，可能会发生两个参与者在两种资源之间“反弹”，从未获得它，但总是屈服于另一种资源。

### 3.1.5 竞争条件(Race condition)

当外部非确定性效应可能违反关于一组事件的排序的假设时，我们将其称为竞争条件(Race condition)。 当多个线程具有共享可变状态时，通常会出现竞争条件，并且状态上的线程操作可能会交错，从而导致意外行为。 虽然这是一种常见情况，但共享状态不一定具有竞争条件。 一个示例可以是客户端将无序分组（例如UDP数据报）P1，P2发送到服务器。 由于数据包可能通过不同的网络路由传输，因此服务器可能先接收P2，然后接收P1。 如果消息中不包含有关其发送顺序的信息，则服务器无法确定它们是以不同的顺序发送的。 根据数据包的含义，这可能会导致竞争条件。

>注意：Akka提供的关于给定一对 Actor 之间发送的消息的唯一保证是他们的顺序总是被保留。 查看后面消息传递可靠性章节

### 3.1.6 非阻塞保证（进度条件）

如前面部分所讨论的，由于多种原因阻塞是不可取的，包括死锁的危险和系统中的吞吐量降低。 在以下部分中，我们将讨论具有不同强度的各种非阻塞属性。


** Wait-freedom **

如果保证每个调用都以有限的步数完成，则该方法是等待的(wait-freed)。 如果方法是无限制的(bounded wait-free)，则步数具有有限的上限。

从这个定义可以看出，wait-free 方法永远不会阻塞，因此不会发生死锁。 此外，由于每个参与者可以在有限数量的步骤之后（当呼叫结束时）进展，所以 wait-free 方法没有饥饿。

** Lock-freedom **

Lock-freedom 是一种比 wait-freedom 更弱的属性。 在 lock-free 调用的情况下，无限次地某些方法在有限数量的步骤中完成。 此定义意味着无锁调用不会出现死锁。 另一方面，某些调用在有限数量的步骤中完成的保证不足以保证所有调用最终完成。 换句话说，lock-freedom 不足以保证饥饿锁。

** Obstruction-freedom **

Obstruction-freedom 是这里讨论的最弱的非阻碍保证。 如果一个方法在一个时间点之后被隔离执行（其他线程没有任何步骤，例如：被暂停），则该方法被称为无阻塞(obstruction-free)，它以有限的步数完成。 所有无锁物体都是无阻碍的，但反之则通常不正确。


乐观并发控制（OCC）方法通常是无障碍的。 OCC的方法是每一个参与者尝试对共享对象执行其操作，但如果参与者检测到其他人的冲突，则会回滚修改，并根据某些计划再次尝试。 如果有一个时间点，其中一个参与者是唯一尝试的参与者，则操作将成功。

### 3.1.7 推荐文献

- The Art of Multiprocessor Programming, M. Herlihy and N Shavit, 2008. ISBN 978-0123705914 [The Art of Multiprocessor Programming](https://www.e-reading.club/bookreader.php/134637/Herlihy,_Shavit_-_The_art_of_multiprocessor_programming.pdf) 
- Java Concurrency in Practice, B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes and D. Lea, 2006.  ISBN 978-0321349606 [Java Concurrency in Practice](https://pdfs.semanticscholar.org/3650/4bc31d3b2c5c00e5bfee28ffc5d403cc8edd.pdf)

## 3.2 Actor 系统

Actors 是封装状态和行为的对象，它们只通过交换放在收件人邮箱中的邮件进行通信。 从某种意义上说，actors 是最严格的面向对象编程形式，但它更适合将他们视为人：在用 Actors 模型解决方案时，设想一群人并为他们分配子任务，将他们的功能安排到一个组织结构，并考虑如何处理升级失败（所有这些都是因为没有真正与人打交道，这意味着我们不必关心自己的情绪状态或道德问题）。 然后，结果可以作为构建软件实现的心理支架。

>注意：ActorSystem是一个重量级结构，将分配1。。 N个线程，因此每个逻辑应用程序创建一个。

### 3.2.1 层次结构

就像在经济组织中一样，actors 自然形成等级制度。 监督程序中某个功能的一个角色可能希望将其任务分解为更小，更易于管理的部分。 为此目的，它启动它监督的 child actor。 虽然这里解释了监督的细节，但我们将集中讨论本节中的基本概念。 唯一的先决条件是要知道每个 actor 都有一个主管(supervisor)，即创建它的 actor。

Actor systems 典型特征是任务被分割和委派，直到它们变得足够小以便能单片处理。 在这样做时，不仅任务本身结构清晰，而且可以根据他们应该处理哪些消息，他们应该如何正常反应以及应该如何处理失败来对所产生的参与者进行推理。 如果一个 actor 没有处理某种情况的手段，它会向其主管(supervisor)发送相应的失败消息，寻求帮助。 然后递归结构允许在正确的级别处理失败。


将其与分层软件设计进行比较，该设计很容易转化为防御性编程，目的是不泄漏任何故障：如果将问题传达给合适的人，则可以找到比尝试将所有内容“置于地毯下”更好的解决方案。

现在，设计这样一个系统的困难在于如何决定谁应该监督什么。 当然没有单一的最佳解决方案，但有一些指南可能会有所帮助：

- 如果一个 Actor 管理另一个 Actor 正在做的工作，例如 通过传递子任务，经理应该监督孩子。 原因是经理知道预期会出现哪种故障以及如何处理故障。 
- 如果一个 Actor 携带非常重要的数据（即，如果可以避免，其状态不会丢失），该行为者应该向其监督的 children 侦听任何可能存在危险的子任务，并在适当时处理这些 children 的失败。 根据请求的性质，最好为每个请求创建一个新子项，这样可以简化收集回复的状态管理。 这被称为Erlang的“错误内核模式”(Erlang "Error Kernel Pattern")。
- 如果一个 Actor 依赖另一个 Actor 执行其职责，它应该观察其他 Actor 的活动并在收到终止通知时采取行动。 这与监督不同，因为观看方对 supervisor 策略没有影响，并且应该注意，单独的功能依赖性不是用于决定将某个子主体放置在层次结构中的何处的标准。

这些规则当然总是有例外，但无论你是遵守规则还是违反规则，你都应该有理由。

### 3.2.2 配置容器

作为合作Actor集合的actor系统是管理共享设施（如调度服务，配置，日志记录等）的自然单元。具有不同配置的多个actor系统可以在同一JVM中共存而没有问题，没有全局共享状态, 在Akka本身。 将此与 Actor 系统之间的透明通信（在一个节点内或通过网络连接）相结合，可以看到 Actor 系统本身可以用作功能层次结构中的构建块。

### 3.2.3 Actor 最佳实践
1. Actor 应该像称心的同事一样：高效地完成工作而不必费心地打扰其他人，避免占用资源。 转换为编程，这意味着以事件驱动的方式处理事件并生成响应（或更多请求）。 参与者不应该阻止（即在占用线程时被动地等待）某个外部实体 - 可能是锁，网络套接字等 - 除非它是不可避免的; 在后一种情况下见下文。
2. 不要在 actor 之间传递可变对象。 为了确保，更喜欢不可变的消息。 如果通过将其可变状态暴露给外部来破坏 actor 的封装，那么您将回到正常的 Java 并发领域并具有所有缺点。
3. Actor 被用作行为和状态的容器，这意味着不要经常在消息中发送行为（使用Scala闭包可能会很诱人）。 其中一个风险是意外地在 Actor 之间共享可变状态，并且这种对 Actors 模型的违反不幸地打破了使 acotor 在编程中进行编程的所有属性。 
4. 顶级角色是 "Error Kernel" 的最内层部分，因此请谨慎创建它们，而不是真正的分层系统。 这有利于故障处理（既考虑配置的粒度和性能），也减少了监护人的压力，如果过度使用则是单点争用。

### 3.2.4 封锁需要谨慎管理

在某些情况下，进行阻塞操作是不可避免的，即使线程在不确定的时间内进入休眠状态，等待外部事件发生。 示例是传统的 RDBMS 驱动程序或消息传递API，其根本原因通常是（网络）I/O 层之下发生。 面对这种情况时，您可能想要将阻塞调用封装在 Future 中并使用它，但这种策略太简单了：当应用程序运行时，您很可能会发现瓶颈, 内存或线程耗尽加载。


“阻塞问题”的适当解决方案的非详尽清单包括以下建议：

- 在一个 actor（或由 router Java 管理的一组actor）中进行阻塞调用，确保配置一个专用于此目的或足够大小的线程池。
- 在Future中进行阻塞调用，确保在任何时间点对此类调用的数量没有达到上限（提交此类无限数量的任务将耗尽您的内存或线程限制）。
- 在Future中执行阻塞调用，提供一个线程池，其中包含适用于运行应用程序的硬件的线程数上限。
- 专门用于管理一组阻塞资源（例如，驱动多个通道的NIO选择器）并在事件消息发生时调度事件。

第一种可能性特别适用于本质上是单线程的资源，例如数据库句柄，传统上一次只能执行一个未完成的查询并使用内部同步来确保这一点。 一种常见的模式是为N个actor创建路由器，每个actor包含一个数据库连接并处理发送到路由器的查询。 然后必须调整数量N以获得最大吞吐量，这将取决于在哪个硬件上部署哪个DBMS。

>注意: 配置线程池是最好委托给Akka的任务，只需在application.conf中配置并通过ActorSystem Java实例化


### 3.2.5 你不应该关心的是什么

actor系统管理它配置为使用的资源，以便运行它包含的actor。 在一个这样的系统中可能有数百万个 actor，毕竟咒语是将它们视为丰富的，并且它们的重量仅为每个实例大约300字节的开销。 当然，应用程序作者无法控制在大型系统中处理消息的确切顺序，但这也不是预期的。 退后一步，放松，而Akka在引擎盖下举重。

## 3.3 Actor 是什么？

上一节关于Actor Systems的部分解释了actor如何形成层次结构，并且是构建应用程序时的最小单元。 本节将单独查看一个这样的actor，解释在实现它时遇到的概念。 有关所有详细信息的更深入参考，请参阅Untyped Actors（Java）。

actor是State，Behavior，Mailbox，Child Actors和Supervisor Strategy的容器。 所有这些都封装在Actor Reference之中。 一个值得注意的方面是演员有一个明确的生命周期，当不再被引用时它们不会被自动销毁; 在创建一个之后，您有责任确保它最终也会被终止 - 这也可以让您控制在Actor终止时如何释放资源。

### 3.3.1 Actor Reference

如下所述，需要从外部屏蔽 actor 对象以便从 actor 模型中受益。 因此，使用 actor 引用将 actor 表示到外部，actor 引用是可以自由且无限制地传递的对象。 这分为内部和外部对象，可以实现所有所需操作的透明性：重新启动 actor 而无需在其他地方更新引用，将实际的 actor 对象放在远程主机上，向完全不同的应用程序中的 actor 发送消息。 但最重要的方面是，除非 actor 本身不明智地发布这些信息，否则不可能从内部看一个 actor 并掌握其状态。

### 3.3.2 State

Actor 对象通常包含一些反映 actor 可能处于的状态的变量。这可以是一个显式状态机（例如使用 fsm-scala 模块），也可以是一个计数器，一组监听器，待处理请求等。 这些数据使演员有价值，必须保护他们免受其他 actor 的修改。 好消息是 Akka Actor 在概念上每个都有自己的轻量级线程，完全屏蔽了系统的其他部分。 这意味着您不必使用锁同步访问，而只需编写您的 actor 代码而不必担心并发性。

在幕后，Akka 将在一组真实线程上运行多组 actor，通常许多 actor 共享一个线程，并且一个 actor 的后续调用最终可能会在不同的线程上进行处理。 Akka 确保此实现细节不会影响处理 actor 状态的单线程。

因为内部状态对于 Actor 的操作至关重要，所以具有不一致的状态是致命的。 因此，当actor失败并由其主管(Supervisor)重新启动时，状态将从头开始创建，就像首次创建 actor 一样。 这是为了实现系统自我修复的能力。

可选地，通过持久保存收到的消息并在重新启动后重放它们，可以自动将actor的状态恢复到重启之前的状态（请参阅persistence-scala）。


### 3.3.3 行为

每次处理消息时，都会根据 actor 的当前行为进行匹配。 行为是指定义在该时间点对消息作出反应的动作的函数，例如，如果客户端被授权则转发请求，否则拒绝它。 此行为可能会随时间而改变，例如 因为不同的客户端会随着时间的推移获得授权，或者因为参与者可能会进入“服务中断” ("out-of-service") 模式而后来又回来了。 这些更改是通过在状态变量中对它们进行编码来实现的，这些状态变量是从行为逻辑中读取的，或者函数本身可以在运行时被换出，请参阅 become 和 unbecome 的操作。 但是，在构造 actori 对象期间定义的初始行为是特殊的，因为重新启动 actori 会将其行为重置为此初始行为。

### 3.3.4 Mailbox

一个 Actor 的目的是处理消息，这些消息从其他 actors（或 Actor System 外部）发送给这个 actor。 连接发送者和接收者的片段是演员的邮箱(Mailbox)：每个 Actor 只有一个 Mailbox，所有发件人都将其邮件排入队列。 入队以发送操作的时间顺序发生，这意味着由于跨线程分配 actor 的明显随机性，从不同的 actor 发送的消息可能在运行时没有定义的顺序。 另一方面，从同一个 actor 向同一目标发送多个消息将以相同的顺序排列它们。

有不同的邮箱实现可供选择，默认为 FIFO(First in first out 先进先出)：由 actor 处理的消息的顺序与它们排队的顺序相匹配。 这通常是一个很好的默认设置，但应用程序可能需要优先处理某些消息而不是其他消息。 在这种情况下，优先级邮箱不会总是排在最后，而是排在消息优先级给定的位置，甚至可能位于前面。 在使用这样的队列时，处理的消息的顺序自然会由队列的算法定义，并且通常不是 FIFO 。

Akka 与其他一些 actor 模型实现的不同之处在于，当前行为必须始终处理下一个出列的消息，没有扫描邮箱以查找下一个匹配的消息。 无法处理消息通常会被视为失败，除非覆盖此行为。

### 3.3.5 Child Actors

每个 actor 都可能是一个主管(supervisor)：如果它创建了子任务来委派子任务，它将自动监督(supervise)它们。 子项列表保存在 actor 的上下文中，并且 actor 可以访问它。 通过创建（context.actorOf（...））或停止（context.stop（child））子项来完成对列表的修改，并立即反映这些操作。 实际的创建和终止操作以异步方式发生在幕后，因此它们不会“阻塞(block)”他们的主管(supervisor)。

### 3.3.6 Supervisor 策略

Actor 的最后一部分是处理其 children 故障(faults)的策略。 然后，Akka透明地完成故障处理，对每个进入的故障应用 Supervision and Monitoring 章节中描述的策略之一。 由于这种策略是 Actor System 结构的基础，因此一旦创建了 Actor，就无法改变创建。

考虑到每个 Actor 只有一个这样的策略，这意味着如果不同的策略适用于一个参与者的各个 children ，那么应该将 children 分组到具有匹配策略的中间主管(supervisors)之下，再次优先考虑 actor systems 的结构。 将任务分解为子任务。　　

### 3.3.7 合适中断 Acotr

一旦一个actor终止，即以一种无法通过重启方式处理的失败，它会自行停止或被其主管停止，释放其资源，将所有剩余的消息从其邮箱中排入系统的“死信邮箱”中。 将它们作为 DeadLetters 转发到 EventStream。 然后，使用系统邮箱在 actor 引用中替换邮箱，将所有新消息作为 Deadletters 重定向到 EventStream。 尽管如此，这是在尽力而为的基础上完成的，因此不要依赖它来构建“保证交付”(guaranteed delivery)。

不仅仅是默默地转储消息的原因受到了我们的测试的启发：我们在转发了死信的事件总线上注册了TestEventListener，并且会记录每个收到的死信的警告 - 这对解密非常有帮助 更快地测试失败。 可以想到，该特征也可用于其他目的。

## 3.4 Supervision and Monitoring

本章概述了监督背后的概念，提供的原语及其语义。 有关如何将其转换为实际代码的详细信息，请参阅Scala和Java API的相应章节。

### 3.4.1 Supervision 是什么？

正如Actor Systems中所描述的那样，主管(Supervisor)描述了 Actors 之间的依赖关系：主管(Supervisor)将任务委托给下属，因此必须响应他们的失败。 当下属检测到故障（即抛出异常）时，它会暂停自身及其所有下属并向其主管发送消息，表示发生故障。 根据要监督的工作性质和失败的性质，主管(Supervisor)可以选择以下四种选择：

- 恢复下属，保持其累积的内部状态
- 重启下属，清除其累积的内部状态
- 永久停止下属
- 升级失败，从而导致自己失败

始终将 Actor 视为监督层级的一部分非常重要，这解释了第四个存在选择（作为一名主管也从属于另一位上级主管），并对前三名有影响：恢复一个 Actor 需要恢复其所有下属，重新启动一个 Actor 需要重新启动其所有下属（但请参见下文了解更多详情），同样终止 Actor 也将终止其所有下属。 应该注意的是，Actor 类的 preRestart hook 的默认行为是在重新启动之前终止其所有子节点，但是可以重写此挂钩; 递归重启适用于执行此挂钩后剩下的所有子节点。

每个主管配置有一个功能，将所有可能的故障原因（即例外）转换为上面给出的四个选择之一; 值得注意的是，此函数不会将失败的 actor 的身份作为输入。 很容易想出结构的例子，这可能看起来不够灵活，例如： 希望将不同的策略应用于不同的下属。 在这一点上，理解监督是关于形成递归故障处理结构是至关重要的。 如果你试图在一个层面做太多，那将很难推理，因此在这种情况下推荐的方法是增加一定程度的监督。

Akka实施了一种称为“父母监督”的特定形式。 actor 只能由其他 actor 创建 - 其中顶级 actor 由库文件提供 - 每个创建的 actor 都由其父级监督。 这种限制使得行动者监督等级的形成是隐含的，并鼓励合理的设计决策。 应该指出的是，这也保证了 actor 不能从外部成为孤儿或附属于监督者，否则可能会让他们不知不觉。 此外，这为 actor 应用程序的（子树）提供了一个自然而干净的关闭过程。

>注意:与监督相关的父子通信由特殊系统消息发生，这些消息具有与用户消息分开的自己的邮箱。 这意味着监督相关事件相对于普通消息没有确定性排序。 通常，用户不能影响正常消息和失败通知的顺序。 有关详细信息和示例，请参阅“讨论：消息顺序”部分。

### 3.4.2 顶层 Supervisors

![The One Who Walks The Buttles Of Space Time](https://github.com/mysonhushu/akka-java-document-zh/blob/master/manuscript/images/TheOneWhoWalksTheButtlesOfSpaceTime.png)

演员系统将在其创建过程中启动至少三个演员，如上图所示。 有关actor路径的后果的更多信息，请参阅Actor路径的顶级范围。

```
/user: The Guardian Actor
```
